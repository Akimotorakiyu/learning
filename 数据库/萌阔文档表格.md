# 萌阔文档表格数据库增删查改的流程的现实理解于应用

UUID为文档表格的唯一编码

## 简单操作

删除、查找操作不变更数据库内容，核心是需要被操作文档表格的索引或过滤条件，算一步操作

1. 索引或过滤条件（包括索引或过滤条件（以得到文档表格UUID））
2. 操作

## 三步操作

增、改操作变更数据库内容，由两部操作组成

增

1. 空纸头
2. 编辑数据内容
3. 操作（创建一张文档表格（计算一个UUID），更新内容）

改

1. 拿到表格**副本**
2. 编辑数据内容（包括索引或过滤条件（以得到UUID））
3. 操作（更新内容）

尝试将增、改的第一步合并。

相对于增，改的特点在于数据内容里包括索引或过滤条件

对比实际填表，每一张表本质上都是唯一的，都有物理上唯一的UUID编码，表先于内容而存在，我们做的只是填表——改表的内容。

故可以将增操作变为

1. 请求一张空表（创建一张表（计算一个UUID））
2. 传递UUID=》改的操作

## 页面关系分析

页面

> 查看文档目录<表格>
> 删除文档<按钮>
> 新增文档<按钮>
> 编辑文档<表格，更新按钮>

现实中，对表格**副本**（可能是多个副本），进行操作时候，仍可以浏览翻看其他文档和副本。所以文档目录页面和编辑文档页面是并列的是相互独立的，但是编辑文档页面是随着文档副本呈现的，也就是说实际上可能同时呈现多个副本编辑页面。

## 页面设计指导思想

文档目录页面和编辑文档页面是并列的是相互独立的。
应为有多少文档副本在被编辑就有多少编辑页面。

viewTable[{wordTable-0},{wordTable-1},...,{wordTable-N}]

editTable[{wordTable-I},{wordTable-J},...,{wordTable-K}]

editTable里的文档表格和viewTable相互独立。
即就文档传递过程中为**值传递**，~~不是引用传递~~。
（在JS中的示例传递方法JSON.parse(JSON.stringify(data))）

### vue组件设计

鉴于这是一种常用组件，所以可以对其进行组件化开发。

通用viewer层。

根据实际情况功能的viewer层，独立的viewer层。

视图层：进行组件间通信。数据储存层。

编辑器：根据待编辑的数据，生成多个编辑器。

挂载->获取数据

删除->获取数据

编辑->把数据放到一个编辑数组->保存->获取数据

增加->获取数据

## 覆盖问题

### 多版本

文档编辑，要回溯历史，或者查看历史版本，需要版本控制。
简单上，可以用数组保存。

（在JS中比较两个JSON是否相同方法JSON.stringify(data_i))==JSON.stringify(data_i+1)）

### 分支

多人同时编辑一份文档表格，并先后保存，结果是什么？
一般而言，其结果为后保存者的文档表格。

但实际上，这必然存在一个冲突问题，这个问题解决的本质原理是文档表格的分支管理。